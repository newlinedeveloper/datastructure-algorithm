Let’s dive into **Heaps 2: Inserting into, Retrieving from a Binary Min Heap**, and understand **heapification** in a **binary min-heap** context.

---

## 🌟 What is a Min-Heap?
A **Min-Heap** is a:
- **Complete binary tree**
- Where each parent node is **less than or equal to** its children.
- The **smallest element** is always at the root.

---

## 🧩 Binary Heap in Array Form
Since a binary heap is a complete binary tree, we can store it in an array:

For node at index `i`:
- **Left child** = `2i + 1`
- **Right child** = `2i + 2`
- **Parent** = `(i - 1) / 2` (integer division)

---

## 🔧 Inserting into Min Heap (Push)

### Step-by-step:
1. Add the new element at the **end of the array**.
2. **Bubble up** (heapify up):
   - While the current node is **less than its parent**, **swap** them.
   - Repeat until heap property is restored.

### Example:
Inserting `1` into `[3, 5, 4]`:
```
Step 1: [3, 5, 4, 1]
Step 2: Swap 1 with 5 → [3, 1, 4, 5]
Step 3: Swap 1 with 3 → [1, 3, 4, 5]
```

---

## 🗑️ Removing from Min Heap (Pop)

### Step-by-step:
1. Remove the root (minimum element).
2. Replace root with **last element** in the array.
3. **Bubble down** (heapify down):
   - Compare with left and right child.
   - Swap with the **smaller child** if needed.
   - Repeat until heap property is restored.

### Example:
Removing from `[1, 3, 4, 5]`:
```
Step 1: Remove 1, replace with 5 → [5, 3, 4]
Step 2: Swap 5 with 3 → [3, 5, 4]
```

---

## 🧠 Heapify (Building Heap from Unordered Array)

### Method: Bottom-Up Heapify
Given an array, convert it into a min-heap by:
1. Start from the **last non-leaf node** (`n/2 - 1`)
2. Call **heapify down** on each node up to root.

### Time Complexity: `O(n)`
Yes, building a heap is **linear**, not `O(n log n)`!

---

## ✅ Go Code Example (Using container/heap)

```go
package main

import (
	"container/heap"
	"fmt"
)

// IntHeap implements heap.Interface (min-heap)
type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x any) {
	*h = append(*h, x.(int))
}

func (h *IntHeap) Pop() any {
	old := *h
	n := len(old)
	val := old[n-1]
	*h = old[:n-1]
	return val
}

func main() {
	h := &IntHeap{4, 2, 7}
	heap.Init(h)
	heap.Push(h, 1)
	fmt.Println("Min:", (*h)[0])   // 1
	fmt.Println("Pop:", heap.Pop(h)) // 1
	fmt.Println("Next Min:", (*h)[0])
}
```

---

## 🧮 Time Complexities

| Operation     | Time     |
|---------------|----------|
| Insert        | O(log n) |
| Delete min    | O(log n) |
| Get min       | O(1)     |
| Build heap    | O(n)     |

---

## 🚀 Summary

| Concept        | Key Idea                                                                 |
|----------------|--------------------------------------------------------------------------|
| Min Heap       | Complete binary tree with parent ≤ children                              |
| Insertion      | Add to end, bubble up                                                    |
| Deletion       | Replace root with last, bubble down                                      |
| Heapify        | Turn array into heap using bottom-up approach                            |
| Go support     | `container/heap` interface provides flexible heap usage                  |

---

Let me know if you'd like:
- Heap sort implementation
- Max-heap version
- Visual explanations of heapify steps
- Practice problems using heaps (Dijkstra, Kth smallest, etc.)
